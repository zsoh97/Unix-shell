package sg.edu.nus.comp.cs4218.impl.ef2;

import org.apache.commons.io.input.BrokenInputStream;
import org.apache.commons.io.output.BrokenOutputStream;
import org.junit.jupiter.api.*;

import sg.edu.nus.comp.cs4218.Environment;
import sg.edu.nus.comp.cs4218.exception.AbstractApplicationException;
import sg.edu.nus.comp.cs4218.exception.UniqException;
import sg.edu.nus.comp.cs4218.impl.app.UniqApplication;


import static com.github.stefanbirkner.systemlambda.SystemLambda.tapSystemOut;
import static org.junit.jupiter.api.Assertions.*;
import static sg.edu.nus.comp.cs4218.impl.FilesUtils.*;
import static sg.edu.nus.comp.cs4218.impl.app.UniqApplication.ERR_MUTUAL_EXC;
import static sg.edu.nus.comp.cs4218.impl.util.ErrorConstants.*;
import static sg.edu.nus.comp.cs4218.impl.util.StringUtils.*;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayDeque;
import java.util.Deque;


public class UniqApplicationTest {
    public static final Path CURR_PATH = Paths.get(Environment.currentDirectory);
    public static Deque<Path> files = new ArrayDeque<>();
    private UniqApplication uniqApplicationUnderTest; // Generated by square test

    private static final String NEW_LINE = System.lineSeparator();
    private static final String NON_EXIST_FILE = "nonExist";
    private static final String TEST_FILE1 = "testFile1";
    private static final String SUBFILE = "testDir\\subFile";
    private static final String TEST_DIR = "testDir";
    private static final String LINE1 = "I love CS4218";
    private static final String LINE2 = "Alice";
    private static final String LINE3 = "Bob";
    private static final String LINE4 = "b0B";
    private static final String UNIQ_PREFIX = "uniq: ";
    private static final String FILE1_CONTENT = LINE1 + NEW_LINE + LINE1 + NEW_LINE + LINE1 + NEW_LINE + LINE2 + NEW_LINE + LINE2 + NEW_LINE + LINE3 + NEW_LINE + LINE2 + NEW_LINE + LINE3 + NEW_LINE + LINE4;
    private static final String NON_EXIST_ERR_MSG = ": No such file or directory";
    private static final String IS_DIR_ERR_MSG = ": " + IS_DIRECTORY;
    private static final String BAD_FLAGS_COMBI = ": Combination of flags is not meaningful" + NEW_LINE;
    private static final String HUMAN_INPUT_ONE = LINE1 + NEW_LINE + LINE1 + NEW_LINE + LINE1 + NEW_LINE + LINE2 + NEW_LINE + LINE2 + NEW_LINE + LINE3 + NEW_LINE + LINE2 + NEW_LINE + LINE3 + NEW_LINE + LINE4 + NEW_LINE;
    private static final String OUTPUT_FILE = "uniq-output";
    private static final String NOFLAGSFILE1 = LINE1 + NEW_LINE
            + LINE2 + NEW_LINE
            + LINE3 + NEW_LINE
            + LINE2 + NEW_LINE
            + LINE3 + NEW_LINE
            + LINE4;
    private static final String CFLAG_FILE1 = "3 " + LINE1 + NEW_LINE
            + "2 " + LINE2 + NEW_LINE
            + "1 " + LINE3 + NEW_LINE
            + "1 " + LINE2 + NEW_LINE
            + "1 " + LINE3 + NEW_LINE
            + "1 " + LINE4;
    private static final String SMALLDFLAG_FILE1 = LINE1 + NEW_LINE
            + LINE2;
    private static final String DFLAGFILE1 = LINE1 + NEW_LINE + LINE1 + NEW_LINE + LINE1 + NEW_LINE + LINE2 + NEW_LINE + LINE2;
    private static final String UNIQ_LITERAL = "uniq: ";

    // START OF GIVEN TDD TEST VARIABLES //
    private static final String TEMP = "temp-uniq";
    public static final Path TEMP_PATH = Paths.get(Environment.currentDirectory, TEMP);
    private static final String testInput = "Hello World" + STRING_NEWLINE +
            "Hello World" + STRING_NEWLINE +
            "Alice" + STRING_NEWLINE +
            "Alice" + STRING_NEWLINE +
            "Bob" + STRING_NEWLINE +
            "Alice" + STRING_NEWLINE +
            "Bob" + STRING_NEWLINE;

    private static final String withoutFlagOutput = "Hello World" + STRING_NEWLINE +
            "Alice" + STRING_NEWLINE +
            "Bob" + STRING_NEWLINE +
            "Alice" + STRING_NEWLINE +
            "Bob";

    private static final String withCountFlagOutput = "2 Hello World" + STRING_NEWLINE +
            "2 Alice" + STRING_NEWLINE +
            "1 Bob" + STRING_NEWLINE +
            "1 Alice" + STRING_NEWLINE +
            "1 Bob";

    private static final String withDuplicateFlagOutput = "Hello World" + STRING_NEWLINE +
            "Alice";

    private static final String withAllDuplicateFlagOutput = "Hello World" + STRING_NEWLINE +
            "Hello World" + STRING_NEWLINE +
            "Alice" + STRING_NEWLINE +
            "Alice";
    private final String CURR_DIR = Environment.currentDirectory;

    @BeforeAll
    static void init() throws IOException {
        Files.deleteIfExists(Paths.get(OUTPUT_FILE));
        Files.deleteIfExists(Paths.get("input_file.txt"));
    }

    @AfterAll
    static void terminate() {
        deleteFile(TEST_FILE1);
    }

    @BeforeEach
    void setUp() {
        Environment.currentDirectory = CURR_DIR.concat(CHAR_FILE_SEP + "TestFolders" + CHAR_FILE_SEP + "app" + CHAR_FILE_SEP + "uniqTestFolder");
    }

    @AfterEach
    void tearDown() throws IOException {
        deleteFile(OUTPUT_FILE);
//        createFile(OUTPUT_FILE);
        Environment.currentDirectory = CURR_DIR;
    }

    @AfterEach
    void deleteTemp() throws IOException {
        for (Path file : files) {
            Files.deleteIfExists(file);
        }
    }

    private static Path createFile(String name) throws IOException {
        Path path = Paths.get(Environment.currentDirectory + CHAR_FILE_SEP + name);
        Files.createFile(path);
        files.push(path);
        return path;
    }

    private void writeToFile(Path path, String content) throws IOException {
        Files.write(path, content.getBytes());
    }

    // ## blue cover generated tests Start ##
    // tests for reading "\\\\\\" as filepath
    @Test
    public void testRun3() throws AbstractApplicationException, IOException {
        UniqApplication uniqApplication = new UniqApplication();
        ByteArrayInputStream stdin = new ByteArrayInputStream("AAAAAAAAAAAAAAAAAAAAAAAA".getBytes());
        assertThrows(UniqException.class,
                () -> uniqApplication.run(new String[]{"\\\\\\", "input_file.txt", "input_file.txt"}, stdin, new ByteArrayOutputStream()));
    }

    // tests that flags are set null in method
    @Test
    public void testUniqFromStdin3() throws Exception {
        assertThrows(UniqException.class, () -> (new UniqApplication()).uniqFromStdin(null, true, true, null, "foo.txt"));
    }

    // Tests for mutually excl flags in method call
    @Test
    public void testUniqFromStdin() throws Exception {
        UniqApplication uniqApplication = new UniqApplication();
        assertThrows(UniqException.class, () -> uniqApplication.uniqFromStdin(true, true, true,
                new ByteArrayInputStream("AAAAAAAAAAAAAAAAAAAAAAAA".getBytes()), "foo.txt"));
    }

//    ## blue cover generated tests End ##

//    ## Squaretest generated tests Start ##
    // tests input file path leads to current directory

    @Test
    void testUniqFromStdin_BrokenStdin() throws Exception {
        // Setup
        final InputStream stdin = new BrokenInputStream();
        uniqApplicationUnderTest = new UniqApplication();
        // Run the test
        assertThrows(Exception.class, () -> uniqApplicationUnderTest.uniqFromStdin(false, false, false, stdin, "outputFileName"));
    }
    @Test
    void testRun_BrokenStdin() {
        // Setup
        final InputStream stdin = new BrokenInputStream();
        final OutputStream stdout = new ByteArrayOutputStream();

        // Run the test
        uniqApplicationUnderTest = new UniqApplication();
        assertThrows(AbstractApplicationException.class, () -> uniqApplicationUnderTest.run(new String[]{"value"}, stdin, stdout));
    }

    @Test
    void testRun_BrokenStdout() {
        // Setup
        uniqApplicationUnderTest = new UniqApplication();
        final InputStream stdin = new ByteArrayInputStream("content".getBytes());
        final OutputStream stdout = new BrokenOutputStream();

        // Run the test
        assertThrows(AbstractApplicationException.class, () -> uniqApplicationUnderTest.run(new String[]{"value"}, stdin, stdout));
    }

    @Test
    void testUniqFromStdin_EmptyStdin() throws Exception {
        // Setup
        final InputStream stdin = InputStream.nullInputStream();
        uniqApplicationUnderTest = new UniqApplication();
        // Run the test
        final String result = uniqApplicationUnderTest.uniqFromStdin(false, false, false, stdin, "outputFileName");

        // Verify the results
        assertEquals("", result);
    }

// ## end squaretest generated tests ##

    @Test
    void run_NoFilesWithoutFlag_ReadsFromInputAndDisplaysAdjacentLines() {
        String[] args = {};
        InputStream stdin = new ByteArrayInputStream(testInput.getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals(withoutFlagOutput + STRING_NEWLINE, outputStream.toString());
        });
    }

    @Test
    void run_NoFilesWithCountFlag_ReadsFromInputAndDisplaysCountOfAdjacentLines() {
        String[] args = {"-c"};
        InputStream stdin = new ByteArrayInputStream(testInput.getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals(withCountFlagOutput + STRING_NEWLINE, outputStream.toString());
        });
    }

    @Test
    void run_NoFilesWithDuplicateFlag_ReadsFromInputAndDisplaysRepeatedAdjacentLinesOnlyOnce() {
        String[] args = {"-d"};
        InputStream stdin = new ByteArrayInputStream(testInput.getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals(withDuplicateFlagOutput + STRING_NEWLINE, outputStream.toString());
        });
    }

    @Test
    void run_NoFilesWithAllDuplicateFlag_ReadsFromInputAndDisplaysRepeatedAdjacentLinesRepeatedly() {
        String[] args = {"-D"};
        InputStream stdin = new ByteArrayInputStream(testInput.getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals(withAllDuplicateFlagOutput + STRING_NEWLINE, outputStream.toString());
        });
    }

    @Test
    void run_NoFilesWithDuplicateAndAllDuplicateFlags_ReadsFromInputAndDisplaysRepeatedAdjacentLinesRepeatedly() {
        String[] args = {"-d", "-D"};
        InputStream stdin = new ByteArrayInputStream(testInput.getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals(withAllDuplicateFlagOutput + STRING_NEWLINE, outputStream.toString());
        });
    }

    @Test
    void run_NoFilesWithUnknownFlag_Throws() {
        String[] args = {"-x"};
        InputStream stdin = new ByteArrayInputStream(testInput.getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertThrows(UniqException.class, () -> new UniqApplication().run(args, stdin, outputStream));
    }

    @Test
    void run_NonemptyInputFile_ReadsFileAndDisplaysAdjacentLines() throws IOException {
        Path inputPath = createFile("input_file.txt");
        writeToFile(inputPath, testInput);
        String[] args = {"input_file.txt"};
        InputStream stdin = new ByteArrayInputStream("".getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals(withoutFlagOutput + STRING_NEWLINE, outputStream.toString());
        });
    }

    // New line will not be displayed after result, similar to unix
    @Test
    void run_EmptyInputFile_ReadsFileAndDisplaysNewline() throws IOException {
        createFile("input_file.txt");
        String[] args = {"input_file.txt"};
        InputStream stdin = new ByteArrayInputStream("".getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals("", outputStream.toString());
        });
    }

    @Test
    void run_NonexistentInputFile_Throws() {
        String[] args = {"nonexistent_file.txt"};
        InputStream stdin = new ByteArrayInputStream("".getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertThrows(UniqException.class, () -> new UniqApplication().run(args, stdin, outputStream));
    }

    // New line not printed similar to unix representation
    @Test
    void run_InputFileToOutputFile_OverwritesOutputFile() throws IOException {
        Path inputPath = createFile("input_file.txt");
        Path outputPath = createFile("output_file.txt");
        writeToFile(inputPath, testInput);
        writeToFile(outputPath, "This is the output file.");
        String[] args = {"input_file.txt", Environment.getCurrentDirectory() + CHAR_FILE_SEP + "output_file.txt"};
        InputStream stdin = new ByteArrayInputStream("".getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals("", outputStream.toString());
            assertArrayEquals(withoutFlagOutput.getBytes(), Files.readAllBytes(outputPath));
        });
    }

    // Does not create new line if command does not have output, similar to unix behaviour
    @Test
    void run_InputFileToNonexistentOutputFile_CreatesOutputFile() throws IOException {
        Path inputPath = createFile("input_file.txt");
        writeToFile(inputPath, testInput);
        String[] args = {"input_file.txt", "output_file.txt"};
        InputStream stdin = new ByteArrayInputStream("".getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertDoesNotThrow(() -> {
            new UniqApplication().run(args, stdin, outputStream);
            assertEquals("", outputStream.toString());
            Path outputPath = CURR_PATH.resolve("output_file.txt");
            assertTrue(Files.exists(outputPath));
            assertArrayEquals(withoutFlagOutput.getBytes(), Files.readAllBytes(outputPath));
            Files.deleteIfExists(outputPath);
        });
    }

    @Test
    void run_NonexistentInputFileToOutputFile_Throws() throws IOException {
        Path outputPath = createFile("output_file.txt");
        writeToFile(outputPath, "This is the output file.");
        String[] args = {"input_file.txt", "output_file.txt"};
        InputStream stdin = new ByteArrayInputStream("".getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertThrows(UniqException.class, () -> new UniqApplication().run(args, stdin, outputStream));
    }

    @Test
    void run_NonexistentInputFileToNonexistentOutputFile_Throws() {
        String[] args = {"input_file.txt", "output_file.txt"};
        InputStream stdin = new ByteArrayInputStream("".getBytes());
        OutputStream outputStream = new ByteArrayOutputStream();
        assertThrows(UniqException.class, () -> new UniqApplication().run(args, stdin, outputStream));
    }
    // End of given TDD tests //

    @Test
    void uniqFromFile_InputFileFileNull_ThrowsException() {
        assertThrows(Exception.class, () -> new UniqApplication().uniqFromFile(false, false, false, null, OUTPUT_FILE));
    }

    @Test
    void uniqFromFile_InputFileAndOutputFileNull_ThrowsException() {
        assertThrows(Exception.class, () -> new UniqApplication().uniqFromFile(false, false, false, null, null));
    }

    @Test
    void uniqFromFile_InputFileNonExistent_ReturnsErrorMessage() throws Exception {
        String expectedContent = UNIQ_PREFIX + NON_EXIST_FILE + NON_EXIST_ERR_MSG;
        try {
            new UniqApplication().uniqFromFile(false, false, false, NON_EXIST_FILE, OUTPUT_FILE);
        } catch (UniqException e) {
            assertEquals(expectedContent, e.getMessage());
        }
    }

    @Test
    void uniqFromFile_InputFileNameIsDirectory_ReturnsErrorMessage() throws Exception {
        String expectedContent = UNIQ_PREFIX + TEST_DIR + IS_DIR_ERR_MSG;
        try {
            new UniqApplication().uniqFromFile(false, false, false, TEST_DIR, OUTPUT_FILE);
        } catch (UniqException e) {
            assertEquals(expectedContent, e.getMessage());
        }
    }

    @Test
    void uniqFromFile_InputFileAndOutputFileNameInDirectory_WritesContentToFile() throws Exception {
        new UniqApplication().uniqFromFile(false, false, false, TEST_FILE1, Environment.getCurrentDirectory() + CHAR_FILE_SEP + TEST_DIR + CHAR_FILE_SEP + OUTPUT_FILE);
        String outputContent = Files.readString(Paths.get(Environment.currentDirectory + CHAR_FILE_SEP + TEST_DIR + CHAR_FILE_SEP + OUTPUT_FILE), StandardCharsets.US_ASCII);
        assertEquals(NOFLAGSFILE1, outputContent);
    }

    @Test
    void uniqFromFile_OutputFileNonExistent_ReturnsErrorMessage() throws Exception {
        try {
            new UniqApplication().uniqFromFile(false, false, false, NON_EXIST_FILE, OUTPUT_FILE);
        } catch (UniqException e) {
            String expectedContent = UNIQ_PREFIX + NON_EXIST_FILE + NON_EXIST_ERR_MSG;
            assertEquals(expectedContent, e.getMessage());
        }
    }

    @Test
    void uniqFromFile_OutputFileNameIsDirectory_ReturnsErrorMessage() throws Exception {
        String expectedContent = UNIQ_PREFIX + TEST_DIR + IS_DIR_ERR_MSG;
        try {
            new UniqApplication().uniqFromFile(false, false, false, TEST_DIR, OUTPUT_FILE);
        } catch (UniqException e) {
            assertEquals(expectedContent, e.getMessage());
        }
    }

    @Test
    void uniqFromStdin_NullStdin_ThrowsException() {
        assertThrows(Exception.class, () -> new UniqApplication().uniqFromStdin(false, false, false, null, OUTPUT_FILE));
    }

    @Test
    void uniqFromStdin_NoFlagSystemStdInNoFiles_ReturnsContents() throws Exception {
        System.setIn(new ByteArrayInputStream(HUMAN_INPUT_ONE.getBytes(StandardCharsets.UTF_8)));
        String expectedContent = LINE1 + NEW_LINE + LINE2 + NEW_LINE + LINE3 + NEW_LINE + LINE2 + NEW_LINE + LINE3 + NEW_LINE + LINE4;
        String actualContent = new UniqApplication().uniqFromStdin(false, false, false, System.in, null);
        assertEquals(expectedContent, actualContent);
    }

    @Test
    void run_NoFlagSystemStdInNoFiles_PrintsContents() throws Exception {
        System.setIn(new ByteArrayInputStream(HUMAN_INPUT_ONE.getBytes(StandardCharsets.UTF_8)));
        String expectedOutput = LINE1 + NEW_LINE + LINE2 + NEW_LINE + LINE3 + NEW_LINE + LINE2 + NEW_LINE + LINE3 + NEW_LINE + LINE4 + NEW_LINE;
        String[] args = new String[0];
        String actualOutput = tapSystemOut(() -> new UniqApplication().run(args, System.in, System.out));
        assertEquals(expectedOutput, actualOutput);
    }

    @Test
    void uniqFromStdin_CFlagOnlyFileStdInNoFiles_ReturnsContents() throws Exception {
        InputStream stdin = new FileInputStream(Environment.currentDirectory + CHAR_FILE_SEP + TEST_FILE1);
        try {
            assertEquals(CFLAG_FILE1, new UniqApplication().uniqFromStdin(true, false, false, stdin, null));
        } finally {
            stdin.close();
        }
    }

    @Test
    void run_CFlagOnlyFileStdInNoFiles_PrintsContent() throws Exception {
        try (InputStream stdin = new FileInputStream(Environment.currentDirectory + CHAR_FILE_SEP + TEST_FILE1)) {
            String[] args = new String[]{"-c"};
            String actualOutput = tapSystemOut(() -> new UniqApplication().run(args, stdin, System.out));
            assertEquals(CFLAG_FILE1 + NEW_LINE, actualOutput);
        }
    }

    @Test
    void uniqFromFile_SmallDFlagOnlyNoStdInInputAndOutputFile_ReturnsContents() throws Exception {
        assertEquals(SMALLDFLAG_FILE1, new UniqApplication().uniqFromFile(false, true, false, TEST_FILE1, OUTPUT_FILE));
        String outputContent = Files.readString(Paths.get(CURR_DIR + "/" + OUTPUT_FILE), StandardCharsets.US_ASCII);
        assertEquals(SMALLDFLAG_FILE1, outputContent);
    }

    @Test
    void uniqFromStdin_CapitalDFlagOnlyFileStdInOutputFileOnly_ReturnsContents() throws Exception {
        try (InputStream stdin = new FileInputStream(Environment.currentDirectory + CHAR_FILE_SEP + TEST_FILE1)) {
            String expectedContent = LINE1 + NEW_LINE + LINE1 + NEW_LINE + LINE1 + NEW_LINE + LINE2 + NEW_LINE + LINE2;
            assertEquals(expectedContent, new UniqApplication().uniqFromStdin(false, false, true, stdin, OUTPUT_FILE));
            String outputContent = Files.readString(Paths.get(CURR_DIR + "/" + OUTPUT_FILE), StandardCharsets.US_ASCII);
            assertEquals(expectedContent, outputContent);
        }
    }

    @Test
    void uniqFromFile_MultiFlagsSmallDFlagDFlagNoStdinInputAndOutputFile_Returns() throws Exception {
        System.setIn(new ByteArrayInputStream(HUMAN_INPUT_ONE.getBytes(StandardCharsets.UTF_8)));
        new UniqApplication().uniqFromStdin(false, true, true, System.in, OUTPUT_FILE);
        String outputContent = Files.readString(Paths.get(CURR_DIR + "/" + OUTPUT_FILE), StandardCharsets.US_ASCII);
        assertEquals(DFLAGFILE1, outputContent);
    }

    @Test
    void uniqFromFile_AllFlagsSystemStdinNoFiles_ThrowsException() throws Exception {
        System.setIn((new ByteArrayInputStream(HUMAN_INPUT_ONE.getBytes(StandardCharsets.UTF_8))));
        try {
            assertEquals(UNIQ_LITERAL + ERR_MUTUAL_EXC, new UniqApplication().uniqFromStdin(true, true, true, System.in, null));
        } catch (UniqException ue) {
            String expectedMessage = UNIQ_LITERAL + ERR_MUTUAL_EXC;
            assertArrayEquals(expectedMessage.getBytes(), ue.getMessage().getBytes());
            assertEquals(expectedMessage, ue.getMessage());
        }
    }

    @Test
    void run_MoreThanTwoFilesGivenNoFlags_OutputsContent() throws Exception {
        String[] args = new String[]{TEST_FILE1, OUTPUT_FILE, SUBFILE};
        new UniqApplication().run(args, System.in, System.out);
        String outputContent = Files.readString(Paths.get(CURR_DIR + "/" + OUTPUT_FILE), StandardCharsets.US_ASCII);
        assertEquals(NOFLAGSFILE1, outputContent);
    }

    @Test
    void run_NotRecognizedFlag_ThrowsException() throws Exception {
        try{
            String[] args = new String[]{"-A"};
            new UniqApplication().run(args, System.in, System.out);
        } catch (UniqException e) {
            String expectedContent = UNIQ_LITERAL + "-A: " + ERR_FILE_NOT_FOUND;
            assertEquals(expectedContent, e.getMessage());
        }
    }

    @Test
    void run_RepeatedFlag_OutputsContent() throws Exception {
        try (InputStream stdin = new FileInputStream(Environment.currentDirectory + CHAR_FILE_SEP + TEST_FILE1)) {
            String[] args = new String[]{"-c", "-c"};
            String actualOutput = tapSystemOut(() -> new UniqApplication().run(args, stdin, System.out));
            assertEquals(CFLAG_FILE1 + NEW_LINE, actualOutput);
        }
    }
}